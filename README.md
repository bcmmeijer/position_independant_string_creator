# position_independant_string_creator
Creates a function or asm that fills a buffer with the bytes needed to recreate the given string on runtime. This way, you can use strings in shellcode since it is not position dependant. Not sure if useful but why not :)

# usage
```
> .\gen.py -h
usage: gen.py [-h] -s STRING [-a ARCH] [-f FORMAT]

optional arguments:
  -h, --help                    show this help message and exit
  -s STRING, --string STRING    input string
  -a ARCH, --arch ARCH          Architecture (x86, x64). will be used to choose chunksize
  -f FORMAT, --format FORMAT    Output type. (function, asm)
  ```

# example
```
> .\gen.py --string "test to get position independant data" -a x64 -f asm

mov rax, 0x206f742074736574  
mov QWORD PTR [rcx + 0], rax 
mov rax, 0x69736f7020746567
mov QWORD PTR [rcx + 8], rax
mov rax, 0x646e69206e6f6974
mov QWORD PTR [rcx + 16], rax
mov rax, 0x746e61646e657065
mov QWORD PTR [rcx + 24], rax
mov rax, 0x0000006174616420
mov QWORD PTR [rcx + 32], rax
ret

 ==== Generated bytecode from asm ====
{ 
    0x48, 0xB8, 0x74, 0x65, 0x73, 0x74, 0x20, 0x74, 
    0x6F, 0x20, 0x48, 0x89, 0x01, 0x48, 0xB8, 0x67, 
    0x65, 0x74, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x48, 
    0x89, 0x41, 0x08, 0x48, 0xB8, 0x74, 0x69, 0x6F, 
    0x6E, 0x20, 0x69, 0x6E, 0x64, 0x48, 0x89, 0x41, 
    0x10, 0x48, 0xB8, 0x65, 0x70, 0x65, 0x6E, 0x64, 
    0x61, 0x6E, 0x74, 0x48, 0x89, 0x41, 0x18, 0x48, 
    0xB8, 0x20, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 
    0x00, 0x48, 0x89, 0x41, 0x20, 0xC3 
}
```
```c
#include <Windows.h>
#include <array>
#include <cstdio>

typedef unsigned char u8;
typedef unsigned int u32;

constexpr u32 cstrlen(const char* str) {
	u32 len = 0;
	char* p = (char*)str;
	while (*p++ != '\x0') len++;
	return len + 1;
}

int main() {

    // get string length
	constexpr auto strlen = cstrlen("test to get position independant data");
    // padding
	constexpr auto bufsize = strlen + (sizeof(void*) - (strlen % sizeof(void*)));

    // shellcode
	std::array<u8, 70> sc {
        0x48, 0xB8, 0x74, 0x65, 0x73, 0x74, 0x20, 0x74,
        0x6F, 0x20, 0x48, 0x89, 0x01, 0x48, 0xB8, 0x67,
        0x65, 0x74, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x48,
        0x89, 0x41, 0x08, 0x48, 0xB8, 0x74, 0x69, 0x6F,
        0x6E, 0x20, 0x69, 0x6E, 0x64, 0x48, 0x89, 0x41,
        0x10, 0x48, 0xB8, 0x65, 0x70, 0x65, 0x6E, 0x64,
        0x61, 0x6E, 0x74, 0x48, 0x89, 0x41, 0x18, 0x48,
        0xB8, 0x20, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
        0x00, 0x48, 0x89, 0x41, 0x20, 0xC3
	};

    // allocate buffer with rwx rights
	void* buf = VirtualAlloc(nullptr, sc.size(),
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!buf) return -1;

    // allocate string buffer and zero it
	char* str = new char[bufsize];
	memset(str, 0, bufsize);

    // copy shellcode to buffer
	memcpy(buf, sc.data(), sc.size());

    // call function
	reinterpret_cast<void(*)(char*)>(buf)(str);

    // print string buffer
	printf("%s\n", str);

    // cleanup
	VirtualFree(buf, 0, MEM_RELEASE | MEM_FREE);
	delete[] str;

	return 0;
}

```
```
output: test to get position independant data
```